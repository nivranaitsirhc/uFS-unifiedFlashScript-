#!/sbin/sh
#
#   uniFlashScript
#
#   CodRLabworks
#   CodRCA : Christian Arvin
#

#
#	Collection of General Function useful in recovery
# 
#   NOTE:
#	 This script is dedicated for uniFlashScript installer.sh
#	
#

#
#	05-01-2018 : TARGET
#	Transfer all Basic Functions to aslib script.
#   asExtract   FIXED 5/18/18
#   asInstall   FIXED 5/18/18
#   asWipelist  FIXED 5/18/18
#   asAddon     FIXED 5/18/18
#

#
#  05-01-2018 : Fix ASLIB Logging Function
#

# PRE-INIT
# ___________________________________________________________________________________________________________ <- 110 Char
#

export aslib_version=1000
export aslib_funcbasic="ui_print set_perm set_progress progress get_prop set_file_prop";
export aslib_funcmain="asAddon asExtract asInstall asWipelist"
export aslib_funcadvance="alLog alLSet alLInit def_check def_config_check";
export aslib_logpath=/sdcard/logs/ufs


# VARIABLE CONFIGS
# ___________________________________________________________________________________________________________ <- 110 Char
#
#

# ############################ # This Configs are essential for aslib function operations.
#     CONFIG DEFINATION        # You can create your config file and source it and use the defs found here.
# ############################ # but you need to run the def_config_check() as precaution for invalid configs

# ASLIB CONFIG
export aslib_req=1000;                  # alib required version
export aslib_asWipelist=1               # set to zero to disable wipe function
export aslib_asAddon=1                  # set to zero to disable addon function
export aslib_asInstall=1                # set to zero to disable install function
export aslib_asExtract=1                # set to zero to disable extract function

# ASLIB LOG CONFIGS
export aslib_log_type="flash"           # set to flash or update
export aslib_log_level=3                # set the logging level
export aslib_log_enabled=1              # set to zero to disable aslib Loggin function
export aslib_log_logname="aslog"        # default log name

# ASLIB ADDON CONFIGS
export addon_name="uniFlashScript"      # default addon name
export addon_delay=50                   # default addon delay
export addon_tail="addon_tail.sh"       # default addon template name

# ASLIB PRE_CHECK CONFIGS
export init_pre_check=0;                # ! ESSENTIAL VALUE DO NOT MODIFY !
export init_create_wipelist=0;          # ! ESSENTIAL VALUE DO NOT MODIFY !

export pc_calc_zip_buffer=5             # zip buffer size
export pc_calc_sys_buffer=500           # system buffer
export pc_size_fix=353600;              # fix minimum size requirement if pc_size_zip is undetermined
export pc_totl_sys=0                    # autogen : total system size
export pc_size_zip=0                    # autogen : zip size
export pc_size_min=0                    # autogen : minimum size limit
export pc_free_tmp=0                    # autogen : size of /tmp
export pc_free_sd0=0                    # autogen : size of /sdcard
export pc_free_sd1=0                    # autogen : size of /sdcard1
export pc_free_sys=0                    # autogen : /system free space
export pc_stat_sys=0                    # autogen : 0 if system has no errors
export pc_stat_sd0=0                    # autogen : 0 if sdcard has no errors
export pc_stat_sd1=0                    # autogen : 0 if sdcard1 has no errors
export pc_stat_tmp=0                    # autogen : 0 if tmp has no errors


# VARIABLE DECLARATION  # ! ESSENTIAL VALUE DO NOT MODIFY !	
# ___________________________________________________________________________________________________________ <- 110 Char
#
#

export wipe_list=
export file_list=

export SOURCEDIR=
export SOURCEFS=
export SOURCESYS=                       


# ASLIB COLD_LOG CONFIGS
export flush_logs=1
export cold_log=cold_log

# ASLIB GET_PROP CONFIGS
PROPFILES="/system/default.prop /system/build.prop /data/local.prop /default.prop /build.prop"

# ASLIB DEF_CONFIG_CHECK
loc_of_config=                   # MUST BE DEFINED BY INSTALLER SH or def_config_check() will be disabled
loc_of_aslib=                    # MUST BE DEFINED BY INSTALLER SH or def_config_check() will be disabled

# ASLIB PRINT_HEADER
export TMH0=;
export TMH1="aslib config"
export TMH2="*******************************"
export TMH3="       ASLIB PRINT HEADER"
export TMH4="*******************************"
export TMH5="app: aslib"
export TMH6="src: TEST"
export TMH7="rev: TEST"
export TMH8=;

# list of configs check
export def_config_list="
aslib_req
aslib_asWipelist
aslib_asAddon
aslib_asInstall
aslib_asExtract
aslib_log_type
aslib_log_level
aslib_log_enabled
aslib_log_logname
addon_name
addon_delay
addon_tail
pc_calc_zip_buffer
pc_calc_sys_buffer
pc_size_fix
PROPFILES
"

# ! DEFCHECK CONFIG SPECIFIC SETTING DO NOT MODIFY OR REMOVE!
last_config_loaded=aslib_config

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! # For aslib logging to function properly this config are needed
#    Do not modify this variables      # to be set properly right after aslib has been sourced.
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! # You can config each value on your script after aslib has been loaded.

# CRUCIAL CONFIGS FOR ALLOG
export LT1=cold_log	# ! DO NOT MODITY ! Logging Tag-1 cold_log means disabled
export LT2=cold_log	# ! DO NOT MODITY ! Logging Tag-2 cold_log means disabled
export LT3=cold_log	# ! DO NOT MODITY ! Logging Tag-3 cold_log means disabled
export LT4=cold_log	# ! DO NOT MODITY ! Logging Tag-4 cold_log means disabled

[ -z "$aslib_log_enabled" ] && al_enable=1                   || al_enable=$aslib_log_enabled
[ -z "$aslib_log_type"    ] && aslib_log_type=flash          || aslib_log_type=$aslib_log_type
[ -z "$aslib_log_level"   ] && al_level=1                    || al_level=$aslib_log_level
[ -z "$aslib_log_logname" ] && aslib_log_logname="aslib_log" || aslib_log_logname=$aslib_log_logname
[ -z "$al_init" ] && al_init=0


# SUB FUNCTIONS
# ___________________________________________________________________________________________________________ <- 110 Char
#

##### ASLIB.UI_PRINT.INIT_FD
init_fd(){
	# we know the fd is a pipe and that the parent updater may have been started as
	# 'update-binary 23 fd zipfile'
	for FD in `ls /proc/$$/fd`; do
		readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null
		[ "$?" -eq "0" ] && {
		  ps | grep " 3 $FD " | grep -v grep >/dev/null
		  [ "$?" -eq "0" ] && {
			OUTFD=$FD
			break
		  }
		}
	done
}

##### ASLIB.SUB.UI_PRINT
ui_print() {
	[ -z "$OUTFD" ] && init_fd
	
	echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD;
	echo -n -e "ui_print\n"    >> /proc/self/fd/$OUTFD;
	
	[ -n "$1" ] && alLog "$1"
}

##### ASLIB.SUB.SET_PROGRESS
set_progress() {
	[ -z "$OUTFD" ] && init_fd
	echo "set_progress $1" 1>&$OUTFD;
}

##### ASLIB.SUB.PROGRESS
progress() {
	[ -z "$OUTFD" ] && init_fd
	echo "progress $1 $2 " 1>&$OUTFD;
}

##### ASLIB.SUB.SET_PERM
# - set_perm	input1 input2 input3 input4 input 5
# input1		-> chown user	!--important--!
# input2		-> chown group	!--important--!
# input3		-> chmod setup	!--important--!
# input4		-> target_file	!--important--!
set_perm() {
	$LT2 "I: ASLIB set_perm: setting permission $1 - $2 $3 $4 $5"
	[[ -n "$1" && -n "$2" && -n "$3" && -n "$4" ]] && {
		chown $1.$2 $4
		chown $1:$2 $4
		chmod $3 $4
	}
	
	[ -n "$4" ] && {
		ch_con $4
		[ -n "$5" ] && ch_con_ext $4 $5
	}
}

##### ASLIB.SUB.CH_CON
ch_con() {
	$LT4 "D: ASLIB exec ch_con"
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon -h u:object_r:system_file:s0 $1  >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon -h u:object_r:system_file:s0 $1     >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon -h u:object_r:system_file:s0 $1 >/dev/null 2>&1
	chcon -h u:object_r:system_file:s0 $1                                                >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon u:object_r:system_file:s0 $1     >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon u:object_r:system_file:s0 $1        >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon u:object_r:system_file:s0 $1    >/dev/null 2>&1
	chcon u:object_r:system_file:s0 $1                                                   >/dev/null 2>&1
}

##### ASLIB.SUB.CH_CON_EXT
ch_con_ext() { # sub-function of set_perm
	$LT4 "D: ASLIB exec ch_con_ext"
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox chcon $2 $1   >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox chcon $2 $1	  	>/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox chcon $2     >/dev/null 2>&1
	chcon $2 $1                                                 >/dev/null 2>&1
}

##### ASLIB.SUB.LN_CON
ln_con() {
	$LT4 "D: ASLIB exec ln_con"
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toybox ln -s $1 $2 	>/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/toolbox ln -s $1 $2      >/dev/null 2>&1
	LD_LIBRARY_PATH=$SYSTEMLIB /system/bin/toolbox ln -s $1 $2	>/dev/null 2>&1
	ln -s $1 $2                                                 >/dev/null 2>&1
	ch_con $2                                                   >/dev/null 2>&1
}

##### ASLIB.SUB.IS_MOUNTED
is_mounted() {
	$LT4 "D: ASLIB exec is_mounted with $1 $2"
	[ -n "$2" ] && {
		cat /proc/mounts | grep $1 | grep $2, >/dev/null 2>&1
		s=$?
	} || {
		cat /proc/mounts | grep $1            >/dev/null 2>&1
		s=$?
	}
	[ "$s" == "0" ] && \
	$LT4 "D: ASLIB is_mounted: $1 is mounted $2" || \
	$LT4 "D: ASLIB is_mounted: $1 is not mounted"
	return $s
}

###### ASLIB.SUB.IS_ENABLED
is_enabled() {
	$LT4 "D: ASLIB exec is_enabled with $1"
	[ -z "$1" ] && return 1
	eval ie_t='$'$1
	case $ie_t in
		1|enable|true|True|TRUE|ENABLED|ENABLE) 
			$LT4 "I: ASLIB is_enabled: ENABLED, by $1 set to $ie_t"
			s=0
		;;
		0|disable|false|False|FALSE|DISABLED|DISABLE|' ')
			$LT4 "I: ASLIB is_enabled: DISABLED, by $1 set to $ie_t"
			s=1
		;;
		*) 	$LT4 "E: ASLIB is_enabled: unknown state of $1 set to $ie_t, returning 1"
			s=1
		;;
	esac
	return $s
}


##### ASLIB.SUB.TOOLBOX_MOUNT
toolbox_mount() {
	$LT4 "D: ASLIB exec toolbox_mount $1 $2"
	# default to READ_WRITE
	local RW=rw
	[ ! -z "$2" ] && RW=$2
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/fstab entry"

	local DEV=;
	local POINT=;
	local FS=;
	
	for i in `cat /etc/fstab | grep "$1"`; do
		if [ -z "$DEV" ]; then
			DEV=$i
		elif [ -z "$POINT" ]; then
			POINT=$i
		elif [ -z "$FS" ]; then
			  FS=$i
			break
		fi
	done
	
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
	! mount -t $FS -o $RW $DEV $POINT               >/dev/null 2>&1 && \
	$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
	! mount -t $FS -o $RW,remount $DEV $POINT       >/dev/null 2>&1 || return 0
	
	
	$LT4 "D: ASLIB toolbox_mount: mounting using using /etc/recovery.fstab"
	
	DEV=;POINT=;FS=;
	
	for i in `cat /etc/recovery.fstab | grep "$1"`; do
		if [ -z "$POINT" ]; then
			POINT=$i
		elif [ -z "$FS" ]; then
			FS=$i
		elif [ -z "$DEV" ]; then
			DEV=$i
			break
		fi
	done
	
	if [ "$FS" = "emmc" ]; then
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW $DEV $POINT"
		! mount -t ext4 -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t ext4 -o $RW,remount $DEV $POINT" && \
		! mount -t ext4 -o $RW,remount $DEV $POINT    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW $DEV $POINT" && \
		! mount -t f2fs -o $RW $DEV $POINT            >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t f2fs -o $RW,remount $DEV $POINT" && \
		! mount -t f2fs -o $RW,remount $DEV $POINT    >/dev/null 2>&1 || return 0
	else
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW $DEV $POINT"
		! mount -t $FS -o $RW $DEV $POINT             >/dev/null 2>&1 && \
		$LT4 "D: ASLIB toolbox_mount: exec mount -t $FS -o $RW,remount $DEV $POINT" && \
		! mount -t $FS -o $RW,remount $DEV $POINT     >/dev/null 2>&1 || return 0
	fi
	return 1 # FAILED TO MOUNT
}


##### ASLIB.SUB.REMOUNT_MOUNTPOINT
remount_mountpoint() {
	$LT4 "D: ASLIB exec remount_mountpoint"
	[ -n "$*" ] && {
		! is_mounted $1 $2 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1" && \
		! mount -o $2,remount $1    >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec mount -o $2,remount $1 $1" && \
		! mount -o $2,remount $1 $1 >/dev/null 2>&1 && \
		$LT4 "D: ASLIB remount_mountpoint: exec toolbox_mount $1" && \
		! toolbox_mount $1          >/dev/null 2>&1 && \
		{
			$LT3 "I: ASLIB remount_mountpoint: $1 failed to remount"
			stat=1
		} || {
			$LT3 "I: ASLIB remount_mountpoint: $1 remounted successfully"
			stat=0
		}
		return $stat
	}
}

#####set_system_fpASLIB.SUB.ABORT
abort(){
	$LT4 "D: ASLIB exec abort"
	ui_print "I: Exiting with ERROR $1"
	exit $1
}

##### ASLIB.SUB.WIPE_SYSTEM_FILES
wipe_system_file() {
	$LT4 "D: ASLIB exec wipe_system_file"
	# Added    08:43 08/05/2017
	# Modified 10:20 04/14/2018 - made target specific
	# Delete files inside the target folder
	if [ -e "/system/$1" ]; then
		# determine type
		if [ -d "/system/$1" ]; then
			# delete recursively
			$LT3 "I: ASLIB wipe_system_file: wiping folder -> $1"
			rm -fR "/system/$1"
		elif [ -f "/system/$1" ]; then
			# delete file
			$LT3 "I: ASLIB wipe_system_file: wiping file   -> $1"
			rm -f "/system/$1"
		fi
		# double checked if removed
		[ -e "/system/$1" ] && {
			$LT3 "I: ASLIB wipe_system_file: Failed to wipe"
		}
	else
		$LT3 "I: ASLIB wipe_system_file: skipping file -> $1"
	fi
}

##### ASLIB.SUB.PRE_CHECK
pre_check() {
	$LT4 "D: ASLIB exec pre_check"
	[ "$init_pre_check" -eq "1" ] && {
		$LT2 "I: ASLIB pre_check: not allowed to run twice"
		return 0
	}

	# check only mounted mount-points
	# calculate free space
	is_mounted /tmp rw && {
		pc_free_tmp=$(df -Pk /tmp     | tail -n 1 | awk '{ print $4 }')
		$LT3 "I: ASLIB pre_check: TMP FREE : $pc_free_tmp"
	} || $LT2 "W: ASLIB pre_check: tmp     is not mounted"
	
	is_mounted /sdcard rw && {
		pc_free_sd0=$(df -Pk /sdcard  | tail -n 1 | awk '{ print $4 }')
		$LT3 "I: ASLIB pre_check: SD0 FREE : $pc_free_sd0"
	} || $LT2 "W: ASLIB pre_check: sdcard  is not mounted"
	
	is_mounted /sdcard1 rw && {
		pc_free_sd1=$(df -Pk /sdcard1 | tail -n 1 | awk '{ print $4 }')
		$LT3 "I: ASLIB pre_check: SD1 FREE : $pc_free_sd1"
	} || $LT2 "W: ASLIB pre_check: sdcard1 is not mounted"
	
	is_mounted /system rw && {
		pc_free_sys=$(df -Pk /system  | tail -n 1 | awk '{ print $4 }')
		pc_totl_sys=$(df -Pk /system  | tail -n 1 | awk '{ print $2 }')
		$LT3 "I: ASLIB pre_check: SYS FREE : $pc_free_sys"
		$LT3 "I: ASLIB pre_check: SYS TOTL : $pc_totl_sys"
	} || {
		$LT2 "W: ASLIB pre_check: system  is not mounted"
		pc_system_mounted=false
	}

	pc_size_zip=$(du -ck $ZIP | tail -n 1 | awk '{ print $1 }')
	
	# Compare total system space vs zip total
	
	[[ "$pc_system_mounted" != "false" && "$(($pc_size_zip - $pc_calc_zip_buffer))" -gt "$(($pc_totl_sys - $pc_calc_sys_buffer))" ]] && {
		$LT1 "E: ASLIB pre_check: zip file is too large than system file"
		abort $E_SVZ
	}

	# use size_updatezip as size_limit or use size_fixlimit
	[[ -z "$pc_size_zip" || "$pc_size_zip" -lt 0 ]] && {
		$LT2 "I: ASLIB pre_check: Using pc_size_fix=$pc_size_zip"
		pc_size_min=$pc_size_fix
	}

	# select  mountpoint by first

	if   [ "$pc_size_min"  -lt "$pc_free_tmp" ];then
		SOURCEFS=/tmp
	elif [ "$pc_size_min"  -lt "$pc_free_sd0" ];then
		SOURCEFS=/sdcard
	elif [ "$pc_size_min"  -lt "$pc_free_sd1" ];then
		SOURCEFS=/sdcard1
	else
		ui_print "I: Not enough space left for zip extraction"
		$LT3 "I: ASLIB pre_check: tmp : $pc_free_tmp"
		$LT3 "I: ASLIB pre_check: sd0 : $pc_free_sd0"
		$LT3 "I: ASLIB pre_check: sd1 : $pc_free_sd1"
		$LT3 "I: ASLIB pre_check: sys : $pc_free_sys"
		abort $E_NME;
	fi
	$LT2 "I: ASLIB pre_check: SOURCEFS  -> $SOURCEFS"
	SOURCEDIR=$SOURCEFS/tmp
	$LT2 "I: ASLIB pre_check: SOURCEDIR -> $SOURCEDIR"
	SOURCESYS=$SOURCEDIR/system
	$LT2 "I: ASLIB pre_check: SOURCESYS -> $SOURCESYS"

	[ -e $SOURCESYS ] && {
		$LT2 "I: ASLIB pre_check: cleaning SOURCEFS"
		rm -rf $SOURCESYS/*
	}
	init_pre_check=1
}

##### ASLIB.SUB.CREATE_WIPELIST
create_wipelist() {
	$LT4 "D: ASLIB exec create_wipelist"
	is_enabled init_create_wipelist && {
		$LT2 "I: ASLIB create_wipelist: not allowed to run twice"
		return 0
	}

	[ ! -z "$wipe_list" ] && {
		$LT2 "W: ASLIB create_wipelist: wipe_list non-zero value"
		$LT3 "D: displaying wipe_list values ..\n$wipe_list"
		$LT3 "D: clearing values.."
		wipe_list=
	}

	$LT3 "I: ASLIB create_wipelist: parsing wipe_list from $COREDIR"

	ls $COREDIR/config/wipe_*.list >/dev/null 2>&1  && {
		for WIPE_TARGET in $(ls -1 $COREDIR/config/wipe_*.list); do
			( test -s "$WIPE_TARGET" ) && {
				for FILE_TARGET in $(cat $WIPE_TARGET); do
					wipe_list="${wipe_list}$FILE_TARGET"$'\n'       # Store to wipe_list for addon.d script
				done
			} || $LT2 "I: ASLIB create_wipelist: $WIPE_TARGET skipped, Empty"
		done
	} || $LT3 "W: ASLIB create_wipelist: $COREDIR/config has no wipe list"

	ls $COREDIR/install/wipe_*.list >/dev/null 2>&1 && {
		for WIPE_TARGET in $(ls -1 $COREDIR/install/wipe_*.list); do
			( test -s "$WIPE_TARGET" ) && {
				for FILE_TARGET in $(cat $WIPE_TARGET); do
					wipe_list="${wipe_list}$FILE_TARGET"$'\n'       # Store to wipe_list for addon.d script
				done
			} || $LT2 "I: ASLIB create_wipelist: $WIPE_TARGET skipped, Empty"
		done
	} || $LT3 "W: ASLIB create_wipelist: $COREDIR/install has no wipe list"

	$LT3 "I: ASLIB create_wipelist: fixing wipe_list"
	wipe_list=$(echo "${wipe_list}" | sort -u | sed '/^$/d')

	init_create_wipelist=1
}

##### ASLIB.SUB.INTEGRITY_CHECK
def_check() {
	$LT4 "D: ASLIB exec def_check"
	local ERR_STAT=0
	! is_enabled def_init && {
		# check ZIP def
		[[ -z "$ZIP" || ! -e "$ZIP" ]] && {
			$LT3 "W: ASLIB def_check: var ZIP not defined."
			ERR_STAT=$((++ERR_STAT))
		}
		# check COREDIR def.
		[[ -z "$COREDIR" || ! -e "$COREDIR" ]] && {
			$LT3 "W: ASLIB def_check: var COREDIR not defined."
			ERR_STAT=$((++ERR_STAT))
		}
		# check LIBS def.
		[[ -z "$LIBS" || ! -e "$LIBS" ]] && {
			$LT3 "W: ASLIB def_check: var LIBS not defined."
			ERR_STAT=$((++ERR_STAT))
		}
		# check BINARIES def.
		[[ -z "$BINARIES" || ! -e "$BINARIES" ]] && {
			$LT3 "W: ASLIB def_check: var BINARIES not defined."
			ERR_STAT=$((++ERR_STAT))
		}
		# THROW ERROR
		[ "$ERR_STAT" -gt "0" ] && {
			$LT1 "E: ASLIB def_check: INTEGRITY ERROR $ERR_STAT"
			ui_print "E: DEF_CHECK ERROR"
			exit $ERR_STAT
		} || def_init=true
	}
	# runtime var_def SOURCEFS
	if [[ -n "$SOURCEFS" && ! -e "$SOURCEFS" ]]; then
		$LT3 "D: ASLIB def_check: var_def SOURCEFS defined but not exist"
		ERR_STAT=$(($ERR_STAT+10))
	elif [ -e "$SOURCEFS" ]; then
		$LT3 "D: ASLIB def_check: var_def SOURCEFS  defined"
	else
		$LT3 "E: ASLIB def_check: var_def SOURCEFS  not defined."
		ERR_STAT=$(($ERR_STAT+20))
	fi

	# runtime var_def SOURCEDIR
	if [[ -n "$SOURCEDIR" && ! -e "$SOURCEDIR" ]];then
		$LT3 "D: ASLIB def_check: var_def SOURCEDIR defined but not exist"
		ERR_STAT=$(($ERR_STAT+25))
	elif [ -e "$SOURCEDIR" ];then
		$LT3 "D: ASLIB def_check: var_def SOURCEDIR defined"
	else
		$LT3 "E: ASLIB def_check: var_def SOURCEDIR not defined."
		ERR_STAT=$(($ERR_STAT+35))
	fi

	# runtime var_def SOURCEDIR
	if [[ -n "$SOURCESYS" && ! -e "$SOURCESYS" ]]; then
		$LT3 "D: ASLIB def_check: var_def SOURCESYS defined but not exist"
		ERR_STAT=$(($ERR_STAT+40))
	elif [ -e "$SOURCESYS" ]; then
		$LT3 "D: ASLIB def_check: var_def SOURCESYS defined"
	else
		$LT3 "E: ASLIB def_check: var_def SOURCESYS not defined."
		ERR_STAT=$(($ERR_STAT+50))
	fi

	# throw ERROR
	[ "$ERR_STAT" -gt "0" ] && {
		$LT1 "E: ASLIB def_check: VAR_DEF INTEGRITY ERROR $ERR_STAT"
		return $ERR_STAT
	} || return 0
}

##### ASLIB.SUB.VAR_DEF
def_config_check() {
	$LT4 "D: ASLIB exec def_config_check"
	# logic, aslib has default configs when loaded,
	# but will be overridden by configs defined by $config_loc
	[[ -z "$loc_of_config" || ! -e "$loc_of_config" ]] && {
		$LT2 "W: ASLIB def_config_check: undefined or not existing config_loc. $loc_of_config"
		_e=1
	}
	[[ -z "$loc_of_aslib"  || ! -e "$loc_of_aslib" ]] && {
		tmp_loc_of_aslib="$(dirname $0)""/aslib"
		[ -e "$tmp_loc_of_aslib" ] && {
			loc_of_aslib=$tmp_loc_of_aslib
		} || {
			$LT2 "W: ASLIB def_config_check: undefined or not existing config_loc. $loc_of_aslib"
			_e=1
		}
	}
	[ -z "$def_config_list" ] && {
		$LT2 "W: ASLIB def_config_check: null config list"
	}
	[ "$_e" -eq "1" ] && {
		$LT2 "E: ASLIB def_config_check: integrity error. please check def. not running"
		return 1
	}
	local DEF_ERR=0
	# General Def.
	$LT2 "I: ASLIB def_config_check: checking aslib configs"
	$LT3 "D: ASLIB def_config_check: last loaded config  ## $last_config_loaded ##"
	for CONF in $def_config_list; do 
		eval CONFVAL='$'${CONF}
		[ -n "$CONFVAL" ] && {
			$LT3 "D: ASLIB def_config_check: curConfig: $(printf "%-20s %s\n" $CONF "-> $CONFVAL")"
		} || {
			GVAL=$(get_file_prop $loc_of_config $CONF)
			[ -n "$GVAL" ] && {
				eval $CONF="${GVAL}"
				$LT3 "D: ASLIB def_config_check: ufsConfig: $(printf "%-20s %s\n" $CONF "-> ${GVAL}")"
			} || {
				$LT3 "W: ASLIB def_config_check: $CONF is not defined in $loc_of_config, trying default."
				grep -m1 "$CONF=" "$loc_of_aslib" 2>&1 >/dev/null && {
					GVAL=$(get_file_prop $loc_of_aslib $CONF)
					[ -n "$GVAL" ] && {
						eval $CONF="${GVAL}"
						$LT3 "D: ASLIB def_config_check: defConfig: $(printf "%-20s %s\n" $CONF "-> ${GVAL}")"
					} || {
						$LT3 "D: ASLIB def_config_check:   default: $CONF is defined as default null"
					}
				} || {
					$LT2 "E: ASLIB def_config_check: $CONF has no default def., check your script!"
					DEF_ERR=$((++DEF_ERR))
				}
			}
		}
	done
	[ "$DEF_ERR" -gt "0" ] && {
		$LT1 "W: ASLIB def_config_check: $DEF_ERR configs are not defined properly, please check your def_config_list def."
		return $DEF_ERR
	} || return 0
}

##### ASLIB.SUB.EXTRACT_ZIP
extract_zip() {
	$LT4 "D: ASLIB exec extract_zip"
	[[ -z "$1" || -z "$2" || -z "$3" ]] && {
		$LT1 "E: ASLIB extract_zip: Missing input!"
		$LT3 "D: ASLIB extract_zip: S1 -> $1"
		$LT3 "D: ASLIB extract_zip: S2 -> $2"
		$LT3 "D: ASLIB extract_zip: S3 -> $3"
		return 25
	}
	progress 0 0;
	unzip -o "$1" "$2" -d "$3" || $LT2 "E: ASLIB extract_zip: errors during extraction"
	# | while read DUMMY
	# do
		# $LT3 "D: ASLIB extract_zip: $DUMMY"
		# EE=$(($EE+15))
		# if [ "$EE" -gt "100" ];then
			# EE=0
			# progress 0 1
		# else			
			# progress 0.$EE 0.1
		# fi
	# done
	progress 1 1
	[ ! -e "$3" ] && {
		$LT1 "E: ASLIB extract_zip: unable to extract zip"
		return 1
	} || return 0
}

###### ASLIB.SUB.SET_SYSTEM_FP
set_system_fp() {
	$LT4 "D: ASLIB exec set_system_fp"
	[[ "$(echo ${1} | cut -d / -f 2-2)" != "system" ]] && {
		$LT2 "E: ASLIB set_system_fp: not valid system file input $1"
		$LT3 "W: ASLIB set_system_fp: only system files with full path are accepted"
	}
	
	local _sys="$(echo ${1} | cut -d / -f 3-3)"
	
	case $_sys in
		bin|xbin)
			set_perm 0 2000 0755 $1
			chmod +x $1
		;;
		vendor)
			local _sysv="$(echo ${1} | cut -d / -f 4-4)"
			case $_sysv in
				bin|xbin)
				set_perm 0 2000 0755 $1
				chmod +x $1
				;;
				*)
				set_perm 0 0 0655 $1
				;;
			esac
		;;
		*)
			set_perm 0 0 0655 $1
		;;
	esac
}


# BASIC FUNCTIONS
# ___________________________________________________________________________________________________________ <- 110 Char
#

##### ASLIB.BASIC.WIPE_LIST
asWipelist() {
	$LT1 "I: ASLIB exec asWipelist"
	is_enabled aslib_asWipelist || {
		ui_print "W: asWipelist is DISABLED"
		return 0
	}

	# create wipe list
	create_wipelist;
	
	[ -z "$wipe_list" ] && {
		$LT2 "E: ASLIB asWipelist: wipe_list var is null, maybe create_wipelist failed?"
		return 1
	} || {
		for WIPE in $wipe_list; do
			wipe_system_file "$WIPE"
		done
	}
}

##### ASLIB.BASIC.ASADDON
asAddon() {
	$LT1 "I: ASLIB exec asAddon"
	is_enabled aslib_asAddon || {
		ui_print "W: asAddon is DISABLED"
		return 0
	}
	
	local ERR_STAT=0
	# Check addon tail def. and redef. addon_tail
	if [[ -n "$addon_tail" && -e "$COREDIR/install/$addon_tail" ]]; then
		$LT2 "I: ASLIB asAddon: using install/$addon_tail"
		addon_tail="$COREDIR/install/$addon_tail"
    elif [[ -n "$addon_tail" && -e "$COREDIR/$addon_tail" ]]; then
		$LT2 "I: ASLIB asAddon: using defined addon_tail in CORE."
		addon_tail="$COREDIR/$addon_tail"
	elif [[ -z "$addon_tail" && -e "$COREDIR/addon_tail.sh" ]]; then
		$LT2 "W: ASLIB asAddon: addon_tail is not defined. Using default addon_tail.sh"
		addon_tail="$COREDIR/addon_tail.sh"
	else
		$LT2 "E: ASLIB asAddon: missing addon_tail !"
		ERR_STAT=$((++ERR_STAT))
	fi

	# check flashmode
	[ $aub = "0" ] && {
		$LT2 "E: ASLIB asAddon: This function should be run in flashmode"
		ERR_STAT=$((++ERR_STAT));
	}

	# check file_list & wipe_list
	[[ -z "wipe_list" && -z "file_list" ]] && {
		$LT2 "W: ASLIB asAddon: empty list"
		ERR_STAT=$((++ERR_STAT));
	}

	# check if essentials are defined
	[[ -z "$addon_name" || -z "$uFS_src_ver" || -z "$uFS_rev_ver" ]] && {
		$LT2 "W: ASLIB asAddon: Missing Essential Variables"
		$LT3 "D: ASLIB asAddon: addon_name  -> $addon_name"
		$LT3 "D: ASLIB asAddon: uFS_rev_ver -> $uFS_rev_ver"
		$LT3 "D: ASLIB asAddon: uFS_src_ver -> $uFS_src_ver"
		ERR_STAT=$((++ERR_STAT));
	}

	[ "$ERR_STAT" -gt "0" ] && {
		ui_print "W: Cannot create addon due to errors!"
		return 0
	}

	# set the addon delay
	[ -z "$1" ] && {
		[ ! -z "$addon_delay" ] && {
			ind=90
			$LT2 "W: ASLIB asAddon empty ind; setting to default $ind"
		} || {
			ind=$addon_delay
			$LT2 "I: ASLIB asAddon: using user defined addon_delay -> $addon_delay"
		}
	} || {
		ind=$1
		$LT2 "I: ASLIB asAddon: setting addon_delay to -> $ind"
	}

	# def. generated addon file name
	addon_filename="$ind-$addon_name.sh";
	
	# fix file_list
	file_list=$(echo "${file_list}" | sort -ur  | sed '/^$/d')

	# sed file_list to addon_tail
	$LT2 "I: ASLIB asAddon: injecting install list to $addon_tail"
	for _file_list in $file_list; do
		sed -i "\:cat <<EOF:a$_file_list" $addon_tail
		$LT3 "D: ASLIB asAddon: <- $_file_list"
	done
	
	# fix wipe_list
	wipe_list=$(echo "${wipe_list}" | sort -ur | sed '/^$/d')
	
	# sed the wipelist to addon_tail
	$LT2 "I: ASLIB asAddon: injecting wipe list to $addon_tail"
	for _wipe_file in $wipe_list; do
		sed -i "\:wipe_list=:a$_wipe_file" $addon_tail
		$LT3 "D: ASLIB asAddon: <- $_wipe_file"
	done

	# set addon properties
	$LT2 "I: ASLIB asAddon: setting variables to $addon_tail"
	set_file_prop $addon_tail addon_name    $addon_name
	set_file_prop $addon_tail addon_src_ver $uFS_src_ver
	set_file_prop $addon_tail addon_app_rev $uFS_rev_ver

	# clean-up same name addon.d script
	if [ -e /system/addon.d/$addon_filename ]; then
		$LT3 "D: ASLIB asAddon: removing existing addon script."
		rm -rf /system/addon.d/$addon_filename
	fi

	# create the addon file
	$LT1 "I: ASLIB asAddon: creating and installing $addon_filename"
	install -d /system/addon.d;
	cat $addon_tail >   /system/addon.d/$addon_filename;

	# set permission for addon.d script
	$LT1 "I: ASLIB asAddon: setting permissions for $addon_filename"
	set_perm 0 0 0755 /system/addon.d/$addon_filename
}

##### ASLIB.BASIC.ASEXTRACT
asExtract() {
	$LT1 "I: ASLIB exec asExtract"
	is_enabled aslib_asExtract || {
		ui_print "W: asExtract: is DISABLED"
		return 0
	}
	

	# def check
	def_check;

	# def. the essential directories if not def.
	if [ ! -e "$SOURCEDIR" ]; then
		$LT2 "I: ASLIB asExtract: CREATING DIR $SOURCEDIR"
		mkdir $SOURCEDIR;
	fi

	# extracting system
	$LT1 "I: ASLIB asExtract: EXTRACTING SYSTEM SOURCEDIR"
	$LT3 "D: ASLIB asExtract: ZIP FILE       -> $ZIP"
	$LT3 "D: ASLIB asExtract: EXTRACT TARGET -> system/*"
	$LT3 "D: ASLIB asExtract: EXTRACT TO     -> $SOURCEDIR"

	$LT1 "I: ASLIB asExtract: extracting system files"
	extract_zip "$ZIP" "system/*" "$SOURCEDIR" || { ui_print "E: Error occured during zip extraction."; abort $E_ZEF; }

	[ -e $SOURCESYS ] && {
		$LT2 "I: ASLIB asExtract: SOURCESYS successfully created"
	} || {
		$LT2 "I: ASLIB asExtract: DISABLING asInstall"
		aslib_asInstall=0
	}
}

##### ASLIB.BASIC.ASINSTALL
asInstall() {
	$LT1 "I: ASLIB exec asInstall"
	is_enabled aslib_asInstall || {
		ui_print "W: asInstall: is DISABLED"
		return 0
	}

	# DEF_CHECK
	def_check || {
		$LT1 "I: ASLIB asInstall: ERROR in required ESSENTIAL DIRECTORIES, Please run pre_check() and asExtract() first"
		return 1
	}

	# recheck system mountpoints
	! is_mounted /system rw && {
		ui_print "E: ASLIB asInstall: /system not mounted properly"
		exit 1
	}

	# var. def.
	file_list=;ops_count=0;progress=0;
	progress 0 0;

	# prepare count for fancy progress
	for dummy in $(find $SOURCESYS); do
		ops_count=$((++ops_count));
	done

	ops_arbiter=$(awk "BEGIN {printf \"%.5f\",1/$ops_count}")
	
	# install files
	for TARGET in $(find $SOURCESYS | sort); do
		progress=$(awk "BEGIN {printf \"%.5f\",$progress + $ops_arbiter}")
		progress $progress 1
		FILE=/system${TARGET#$SOURCESYS}
		if [ -d "$TARGET" ] ;then
			_new_install="$(echo "$FILE" | cut -d/ -f 3-4)"
			[ "$_new_install" != "$_old_install" ] && {
				$LT2 "I: ASLIB asInstall <- $_new_install"
				_old_install="$_new_install"
			}
			[ ! -e $FILE ] && {
					mkdir $FILE || $LT4 "E: ASLIB asInstall: Failed to create $FILE" && \
					set_perm 0 0 0755 "$FILE"
			}
		else
			dd if="$TARGET" of="$FILE"
			[ ! -e "$FILE" ] && { $LT3 "E: ASLIB asInstall: Failed to install $FILE"; } || {
				file_list="${file_list}${FILE#/system/}"$'\n';
				set_system_fp "$FILE"
			}
		fi
	done
	progress 1 1
	sleep 3
}







# ADDITIONAL FUNCTIONS
# ___________________________________________________________________________________________________________ <- 110 Char
#

##### ASLIB.LOAD
# Load aslib from strategic locations
aslib_load() {
	ASLIB=;
	ASLIBt=;
	aslib_ver=;
	aslib_req=1000
	# search for default location
	ASLIBLOC=$(find /tmp* /system/addon.d* /sdcard* /data/aslib* -name aslib -type f -follow)
	# test aslib for right version number
	for LIB in $ASLIBLOC;do
		echo "LIB -> $LIB"
		[ ! $(test -s $LIB) ] && {
			# check version of aslib
			if $(cat $LIB | grep aslib_version=); then
				aslib_ver=$(sed "s/aslib_version=//p;d" "$LIB" | awk '{ print $2 }')
				echo "VER -> $aslib_ver"
				if [ $aslib_ver -eq $aslib_req ];then
					ASLIB=$LIB
					break
				elif [ $aslib_ver -gt $aslib_req ];then
					ASLIBt=$LIB
				fi
			fi
		}
	done
	[ -z "$ASLIB" ] && [ -z "$ASLIBt" ] && {
		print "E: aslib was not loaded"
		print "W: switching to basic functions"
		# put the aslib put aslib blank functions here.
		# define a basic function in your script and leave this option blank
	}
	[ -z "$ASLIB" ] && [ ! -z "$ASLIBt" ] && {
		print "W: same version aslib was not located"
		ui_print "I: using aslib $aslib_ver instead of $aslib_req"
		ASLIB=$ASLIBt
		. $ASLIB
	}
	[ ! -z "$ASLIB" ] && {
		. $ASLIB
	}
}

##### ASLIB.ADD.EX_S
ex_s(){
	ui_print "Error: $@"
	exit 1
}

##### ASLIB.ADD.GET_FILE_PROP
get_file_prop() {
	if [ -f "$1" ];then
		prop_f=$1
		prop_v=$2
	elif [ -f "$2" ];then
		prop_f=$2
		prop_v=$1
	else
		$LT3 "E: ASLIB get_file_prop: No valid file"
		return 1
	fi
	grep -m1 "^$prop_v=" "$prop_f" | cut -d= -f2
}

##### ASLIB.ADD.GET_PROP
get_prop() {
	# check known .prop files using get_file_prop
	for f in $PROPFILES; do
		[ -e "$f" ] && {
			prop="$(get_file_prop "$f" "$1")"
			[ -n "$prop" ] && break #if an entry has been found, break out of the loop
		}
	done
	# if prop is still empty
	# try to use recovery's built-in getprop method
	# otherwise output current result , not recommended if using a custom recovery.
	[ -z "$prop" ] && {
		getprop "$1" | cut -c1-
		$LT3 "I: ASLIB get_prop: Cannot determine the actual get prop."
	} || printf "$prop"
}

##### ASLIB.ADD.SET_FILE_PROP
set_file_prop() {
	if [ -f "$1" ];then
		prop_f=$1
		prop_v=$2
		prop_n=$3
	elif [ -f "$2" ];then
		prop_f=$2
		prop_v=$1
		prop_n=$3
	elif [ -f "$3" ];then
		prop_f=$3
		prop_v=$1
		prop_n=$2
	else
		$LT2   "E: ASLIB set_file_prop: No valid file"
		return 1
	fi
	# change $var's value if $var present in the file
	grep -q "$prop_v=" "$prop_f" && (sed "s/^$prop_v=.*$/$prop_v=$prop_n/" -i "$prop_f")
	$LT2 "I: ASLIB set_file_prop: $prop_f <- $prop_v to $prop_n"
}

##### ASLIB.ADD.PRINT_HEADER
print_header(){
	[ -z "$OUTFD" ] && init_fd
	
	set=0;tmh_init=false;

	#[ -z "$TMH0" ] && set=$((++set))

	while true;do
		eval val='$'TMH${set}
		if [ "$val" == "#" ];then
			ui_print " "
		elif [ -n "$val" ]; then
			ui_print "$val"
		elif [ -z "$val" ]; then
			# ignore the first blank TMH
			[ "$tmh_init" == "true" ] && {
				break
			}
			tmh_init=true
		fi
		set=$((++set))
	done
}







# EXPERIMENTAL FUNCTIONS (NOT IMPLEMENTED YET)
# ___________________________________________________________________________________________________________ <- 110 Char
#

##### ASLIB.ADD.ALINIT
alLInit() {
	is_enabled al_init && {
		cold_log "W: ASLIB alLInit: aslib logging has already been initialized!"
		return 1
	}
	
	# remount /sdcard if not mounted
	! is_mounted /sdcard rw && \
	remount_mountpoint /sdcard rw
	
	# create /sdcard/logs folder
	[ ! -e /sdcard/logs ] && {
		$cold_log "I: ASLIB alLInit: creating /sdcard/logs"
		mkdir /sdcard/logs
		[ ! -e /sdcard/logs ] && $cold_log "I: ASLIB alLInit: FAILED in creating DIR"
	}
	
	# create /sdcard/logs/aslib folder
	[ ! -e /sdcard/logs/ufs ] && {
		$cold_log "I: ASLIB alLInit: creating /sdcard/logs/ufs"
		mkdir /sdcard/logs/ufs
		[ ! -e /sdcard/logs/ufs ] && $cold_log "I: ASLIB alLInit: FAILED in creating DIR"
	}

	# create log directory
	[ ! -z "$aslib_log_type" ] && {
		case $aslib_log_type in
			flash|flashmode|flashlog)
				logpath=$aslib_logpath/flash
			;;
			upgrade|upgrademode|upgradelog|ota)
				logpath=$aslib_logpath/ota
			;;
			custom)
				logpath=$aslib_logpath/custom
			;;
			*)	
				logpath=$aslib_logpath/$aslib_log_type
				cold_log "D: ASLIB Custom logtype set, $aslib_log_type"
			;;
		esac
		# create required folder
		[ ! -e $logpath ] && {
			$cold_log "I: ASLIB alLInit: creating $logpath"
			mkdir $logpath
			[ ! -e $logpath ] && $cold_log "I: ASLIB alLInit: FAILED in creating DIR"
		}
		$cold_log "I: ASLIB alLInit: logpath set to $logpath"
	}
	
	# Set log name
	[ -n "$aslib_log_logname" ] && {
		$cold_log "I: ASLIB alLinit: logname set to $aslib_log_logname"
		al_name=$aslib_log_logname
	} || {
		$cold_log "W: ASLIB alLinit: alLinit run without defining aslib_log_name, defualting to aslog"
		al_name=aslog
	}
	
	# Setup log file name
	logfile=$logpath/$al_name'_'$(date "+%Y-%m-%d_%H-%M-%S").log
	$cold_log "I: ASLIB alLInit: logfile set to $logfile"
	
	if [ -e $logfile ]; then
		$cold_log "W: ASLIB alLInit: found existing logfile with the same name, the world must be crazy!"
		$cold_log "D: ASLIB alLInit: removing duplicate logfile.."
		rm -f $logfile
	fi
	
	# COLD_LOG TURN-OVER
	local PRO_LOG="$TMP_LOG"                # TRANSFER LOGS TO PROBITIONARY CONTAINER
	TMP_LOG=                                # CLEAR TMP_LOG
	alLog "I: LOADING COLD_LOGS..$PRO_LOG"  # FLUSH COLD_LOGS to ASLIB LOG
	cold_log=alLog                          # TRANSITION COLD_LOG TO ALLOG
	
	al_init=1
}

##### ASLIB.ADD.ALSET
alLSet() {
	[ -z "$1" ] && {
		# detect inputs
		case $al_enable in
		1|1|enable) al_enable=1
			$cold_log "I: ASLIB alLSet: log enabled"
			;;
		0|0|disable) al_enable=0
			$cold_log "I: ASLIB alLSet: log disabled"
			;;
		esac
	}

	[ "$1" == "name" ] && {
		al_name=$2
		$cold_log "I: ASLIB allSet: logname set to $2"
	}

	[ "$1" == "enable" ] && {
		case $2 in
		True|true|1)
			al_enable=1
			$cold_log "I: ASLIB alLSet: log enabled"
			;;
		False|false|0)
			al_enable=0
			$cold_log "I: ASLIB alLSet: log disabled"
			;;
		esac
	}

	[ "$1" == "type" ] && {
		case $2 in
			flash|flashlogs|flashmode)
				$cold_log "I: ASLIB alLSet: type set to $2"
				aslib_log_type=flash
				;;
			up|upgrade|upgrademode)
				$cold_log "I: ASLIB alLSet: type set to $2"
				aslib_log_type=upgrade
				;;
			*)
				$cold_log "I: ASLIB alLSet: type set to $2"
				aslib_log_type=$2
				;;
		esac

		# we need to call alLInit again
		# alLInit
	}

	[ "$1" == "level" ] && {
		case $2 in
			1)	LT1=alLog
				LT2=alLog
				LT3=alLog
				LT4=cold_log
				$cold_log "I: ASLIB alLSet: log set to 1"
			;;
			2)	LT1=alLog
				LT2=cold_log
				LT3=cold_log
				LT4=cold_log
			   	$cold_log "I: ASLIB alLSet: log set to 2"
			;;
			3)	LT1=alLog
				LT2=alLog
			  	LT3=alLog
				LT4=cold_log
				$cold_log "I: ASLIB alLSet: log set to 3"
			;;
			4)	LT1=alLog
			  	LT2=alLog
				LT3=alLog
				LT4=alLog
				flush_logs=false
				$cold_log "I: ASLIB alLSet: log set to 4"
			;;
			*)	LT1=alLog
				LT2=alLog
				LT3=alLog
				LT4=cold_log
				$cold_log "I: ASLIB alLSet: log set to 1 DEFAULT"
			;;
		esac
	}
	return 0
}

##### ASLIB.ADD.ALLOG
alLog() {
	[ "$al_enable" != 1 ] && return 0

	[ -n "$1" ] && IN="$*" || read IN

	[ -n "$IN" ] && {
		LogTime=`date "+%H:%M:%S"`
		echo 	"$LogTime $IN" >> $logfile
		cold_log "$IN"
	}
}


##### ASLIB.ADD.COLD_LOG
cold_log() {
		TMP_LOG="${TMP_LOG}"$'\n'"$(date "+%H:%M:%S") $1"
		printf "$1\n"
}

flush_logs() {
	is_enabled flush_logs || {
		$LT1 "I: ASLIB flush_logs: Complete log flushing is disabled "
		return 0
	}
	
	UFSTL="/sdcard/logs/ufs/ufs_log_$al_name.log"
	$LT1 "I: ASLIB flush_logs: Flushing complete logs to $UFSTL"
	remount_mountpoint /sdcard rw || $LT1 "E: ASLIB flush_logs: no sdcard access"
	cold_log "DONE FLUSHING.."
	echo "uniFlashScript Flush Logs"$'\n\n\n\n' >> $UFSTL
	echo "FLUSHING COLD_LOGS....$TMP_LOG"       >> $UFSTL
	echo $'\n\n\n\n'                            >> $UFSTL
	$LT1 "I: ASLIB flush_logs: done"
	# copy recovery.log to ufs dir
	(sleep 2;cat /tmp/recovery.log > /sdcard/logs/ufs/$al_name"_recovery.log") &
}

# INIT
# ___________________________________________________________________________________________________________ <- 110 Char
#

# update_binary var check -AslibUpdateBinary- or aub
# SOURCEDIR, BINARIES, INSTALLER, ZIP
[[ -z "$SOURCEDIR" && -z "$BINARIES" && -z "$INSTALLER" && -z "$ZIP" ]] && {
	$cold_log "I: ASLIB Were probably running in ota_mode"
	aub=0
} || {
	$cold_log "I: ASLIB Were probably running in flash_mode"
	aub=1
}

##### INFORM USER THAT ASLIB IS LOADED
$cold_log "I: ASLIB aslib Loaded.."
